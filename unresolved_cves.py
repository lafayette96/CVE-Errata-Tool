import requests
import json
import sys
import getopt
import pprint
import re
import csv
import datetime 
import os.path

API_HOST = 'https://access.redhat.com/hydra/rest/securitydata'
endpoint = '/cve.json'

def save_as_csv(filename: str, data: list):
    header = ['CVE Number', 'Severity', 'Public date', 'URL', 'Description', 'Mitigation', 'Affected products', 'Errata']
    file_exists = os.path.isfile(filename)

    with open(filename, 'a', encoding='UTF8', newline='') as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(header)
        writer.writerow(data)


def get_data(query: str) -> list:
    full_query = API_HOST + query
    r = requests.get(full_query)

    if r.status_code != 200:
        print('ERROR: Invalid request; returned' + str(r.status_code) + 'for the following query: \n' + full_query)

    if not r.json():
        print('\nNo data returned with the following query: \n' + full_query)
        print('\n')
        sys.exit(0)

    return r.json()


def pretty_print_cve(data: list):
    cves_printed = []
    print('\n')
    filename = 'CVE_info_' + datetime.datetime.now().strftime("%Y%m%d-%H%M%S") + '.csv'

    for cve in data:
        # for each CVE, make separate call to API
        cve_query = "/cve/" + cve['CVE']
        cve_data = get_data(cve_query)
   
        # variable to store affected packages and errata info
        affected_packages = {}
        details ='\n'
        errata_product = []
        errata_release_date = []
        errata_advisory = []
        csv_data = []
        details_csv = ''

        # concatenate a list of descriptions into one block of text
        for description in cve_data['details']:
            details += '*) '
            details += description
            details += '\n'
            details_csv += description 

        # check is there are mitigation steps provided
        if "mitigation" in cve_data:
            mitigation = cve_data["mitigation"]["value"]
        else:
            mitigation = "No mitigation strategy provided so far."

        # gather package details
        try:
            for package in cve_data["package_state"]:
                name = package["product_name"]
                fix_state = package["fix_state"]
                if re.search(arg_product, name, re.IGNORECASE): # check if the affected package is within the scope of search
                    if arg_remove_unaffected == 'yes': 
                        if fix_state != "Not affected": # only add "Not affected" packages if the argument --remove-unaffected is not set 
                            affected_packages[name] = fix_state 
                    else:
                        affected_packages[name] = fix_state
        except:
            print('\n**********************************\n\nAn exception occured for: ' + cve['CVE'] + '\nNo affected packages found.' + '\n\n**********************************\n\n')
        

        # Get errata info
        if "affected_release" in cve_data:
            for affected_release in cve_data["affected_release"]:
                errata_product.append(affected_release['product_name'])
                errata_release_date.append(affected_release['release_date'][0:10])
                errata_advisory.append(affected_release['advisory'])
        

        # TODO: figure the logic to decide whether the CVE is resolved or not
        # Show under conditions: 
        # 1) CVEs released within specified time period OK!
        # 2) CVEs released earlier that had the errata released within that period 
        # 3) CVEs released earlier, without errata released

        # below we need to operate on datetimee objects, not strings!
        cve_public_date = datetime.datetime.strptime(cve['public_date'][0:10], "%Y-%m-%d")
        

        if cve_public_date < arg_after_date:
            if errata_product:
                good_erratas = 0
                for x, y, z in zip(errata_product, errata_release_date, errata_advisory):
                    errata_release_date_datetime = datetime.datetime.strptime(y, "%Y-%m-%d")
                    if arg_after_date < errata_release_date_datetime < arg_before_date:
                        good_erratas += 1
                    
                if good_erratas <= 0:
                    continue
        
        if cve['CVE'] not in cves_printed:
            print('CVE Number: \t| Severity: | Public date: | URL: ')
            cves_printed.append(cve['CVE'])
            print('{:<15} | {:<9} | {:<12} | {:<50}'.format(cve['CVE'], cve['severity'], cve['public_date'][0:10], cve['resource_url'])) # print details
            
            # print description
            print('\nDescription: ' + details) 
        
            # print mitigation strategy
            print('Mitigation strategy: \n' + mitigation) 

            # print affected packages
            print('\nPackage state: \t\t\t\t\t\t\t| Fix state:  ') 
            if not affected_packages:
                print("All queried packages are marked as not affected.")
            else:
                for k, v in affected_packages.items():
                    print('{:<63} | {:<20}'.format(k, v))

            #print errata details
            print('\nReleased errata for product: \t\t\t\t\t| Release date: | Advisory name:') 
            if not errata_product:
                print('No errata released for this CVE.')
            else:
                for x, y, z in zip(errata_product, errata_release_date, errata_advisory):
                    print('{:<63} | {:<13} | {:<20}'.format(x, y, z))

            errata_csv = list(zip(errata_product, errata_release_date, errata_advisory))

            csv_data.extend([cve['CVE'],cve['severity'], cve['public_date'][0:10], cve['resource_url'], details_csv, mitigation, affected_packages, errata_csv])
            save_as_csv(filename, csv_data)

            print('\n\n----------------------------------------------------------------------------------------------------------------------------------------------\n\n')
    
    print(cves_printed)
    print('\n')


def parse_input(argv: list) -> str:
    global arg_after
    global arg_after_date
    global arg_after_year_before
    global arg_before
    global arg_before_date
    global arg_product 
    ar_product = ''
    arg_severity = ''
    global arg_remove_unaffected 
    arg_remove_unaffected = 'no'
    arg_help = """\n\t\t  Usage: python3 unresolved_cves.py [options] \n
                  Example: 
                  python3 unresolved_cves.py -a 2022-07-13 -b 2022-07-15 -p "(Fuse 7|Camel K|Quarkus|3scale)" -s important -r yes 

                  -h, --help  show help
                  -a, --after  <YYYY-MM-DD>  show only CVEs release after this date
                  -b, --before  <YYYY-MM-DD>  show only CVEs released before this date
                  -p, --product  <product name>  show affected products (supports Perl compatible regular expressions)
                  -s, --severity  <low, moderate, important>  choose severity
                  -r, --remove-unaffected  <yes/no>  do not show packages that are not affected by the CVE \n"""

    try: 
        opts, args = getopt.getopt(argv[1:], "ha:b:p:s:r:", ["help", "after=", "before=", "product=", "severity=", "remove-unaffected="])
    except:
        print(arg_help)
        sys.exit(2)

    params = ""

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print(arg_help) #print the help message
            sys.exit(2)
        elif opt in ("-a", "--after"):
            arg_after = arg
            arg_after_date = datetime.datetime.strptime(arg_after, "%Y-%m-%d") # requested date e.g. 2022-08-29
            arg_after_year_before = arg_after_date - datetime.timedelta(days = 365) # one year earlier date  e.g. 2021-08-29
            # for now query for all CVEs from one year beofre 'arg_after' date [TESTING]
            if not params:
                params += 'after=' + str(arg_after_year_before)[0:10]
            else: 
                params += '&after=' + str(arg_after_year_before)[0:10]
        elif opt in ("-b", "--before"):
            arg_before = arg
            arg_before_date = datetime.datetime.strptime(arg_before, "%Y-%m-%d")
            if not params:
                params += 'before=' + arg_before
            else:
                params += '&before=' + arg_before
        elif opt in ("-p", "--product"):
            arg_product = arg
            if not params:
                params += 'product=' + arg_product
            else:
                params += '&product=' + arg_product
        elif opt in ("-s", "--severity"):
            arg_severity = arg
            if not params:
                params += 'severity=' + arg_severity
            else:
                params += '&severity=' + arg_severity
        elif opt in ("-r", "--remove-unaffected"):
            arg_remove_unaffected = arg

    return params


if __name__ == "__main__":
    params = parse_input(sys.argv)
    data = get_data(endpoint + '?' + params)
    pretty_print_cve(data)
    #print('\n\n\n')
    #print(csv_data)
    #save_as_csv(csv_data)
